gcc -Wall -Wextra -Wno-unused-parameter -Wno-unused-function -Wno-sign-compare -std=c11 -g3 tcg.c arena.c && ./a.out test2.tc > test.asm 2>/dev/null && nasm -f elf64 -o obj.o test.asm && ld obj.o -o obj && ./obj

alias mk = !gcc -Wall -Wextra -Wno-unused-parameter -Wno-unused-function -Wno-sign-compare -std=c11 -g3 -fsanitize=address,undefined tcg.c arena.c

void
decr_defcnt(MFunction *mfunction, Oper o, Inst *known_def)
{
	size_t remaining_defs = --mfunction->def_count[o];
	if (remaining_defs == 1) {
		mfunction->only_def[o] = known_def;
	} else if (remaining_defs == 0) {
		assert(mfunction->use_count[o] == 0);
	}
}

void
decr_usecnt(MFunction *mfunction, Oper o, )
{
	if (--mfunction->use_count[o] == 0) {
		def->prev->next = def->next;
		def->next->prev = def->prev;
	}
}



int
test()
{
	Arena arena_;
	Arena *arena = &arena_;
	arena_init(arena);
	GArena labels = {0};

	Function *function = arena_alloc(arena, sizeof(*function));
	*function = (Function) {0};
	function->name = STR("fun");
	value_init(&function->base, VK_FUNCTION, (Type *) NULL);

	Block *block = create_block(arena, function);
	Operation *ret = create_operation(arena, block, VK_RETVOID, &TYPE_VOID, 0);
	append_to_block(block, &ret->base);

	MFunction *mfunction = arena_alloc(arena, sizeof(*mfunction));
	memset(mfunction, 0, sizeof(*mfunction));
	mfunction->func = function;
	mfunction->labels = &labels;
	mfunction->mblocks = arena_alloc(arena, 1 * sizeof(mfunction->mblocks[0]));
	mfunction->mblock_cnt = 0; // incremented when each block is inserted

	MBlock *mblock = arena_alloc(arena, sizeof(*mblock));
	memset(mblock, 0, sizeof(*mblock));
	mfunction->mblocks[mfunction->mblock_cnt++] = mblock;
	mblock->insts.kind = IK_BLOCK;
	mblock->insts.subkind = 0;
	mblock->insts.mode = M_NONE;
	mblock->insts.next = &mblock->insts;
	mblock->insts.prev = &mblock->insts;
	mblock->index = mfunction->mblock_cnt - 1;
	mblock->block = block;

	TranslationState ts_ = {
		.arena = arena,
		.labels = &labels,
		.index = R__MAX,
		.stack_space = 8,
		.block = mblock,
		.function = mfunction,
	};
	TranslationState *ts = &ts_;

	Oper a = ts->index++;
	Oper b = ts->index++;
	Oper c = ts->index++;
	// a = 1
	//add_mov_imm(ts, a, 1);
	// b = 2
	//add_mov_imm(ts, a, 2);
	// c = a + b
	add_copy(ts, c, a);
	add_binop(ts, G1_ADD, c, b);

	add_copy(ts, R_RAX, a);
	add_copy(ts, R_RBX, b);
	add_copy(ts, R_RCX, c);

	mfunction->vreg_cnt = ts->index;
	RegAllocState *ras = reg_alloc_state_create(arena);
	reg_alloc_state_init_for_function(ras, mfunction);
	reg_alloc_state_reset(ras);
	ras.to_spill[c] = 8;
	rewrite_program(ras);
	calculate_spill_cost(ras);

	print_mfunction(stderr, mfunction);
	reg_alloc_function(ras, mfunction);
	print_mfunction(stderr, mfunction);
	calculate_def_use_info(mfunction);
	peephole(mfunction, arena, true);
	print_mfunction(stderr, mfunction);

	return 0;
}
